//! RediCacheLayer is a middleware that caches the response of a handler in Redis.
//!
//! It automatically generates a Redis key based on the request path and query parameters. This key is generated by ordering the query parameters alphabetically, which
//! ensures that the request with the same parameters will always have the same key.
//!
//! The middleware checks if the key exists on Redis before calling the handler. If the key exists, it returns the response from Redis.
//! When the key does not exist, it calls the handler, saves the response in Redis, and returns it.
//!
//! # Examples
//!
//! You can add the RedisCacheLayer to your handler by using RedisCacheLayerBuilder like in the following example.
//!
//! ```rust
//! use axum::{handler::get, Router};
//! use axum_redis_utils::middlewares::{RedisCacheLayer, RedisCacheOptions};
//! use std::sync::Arc;
//! use axum_redis_utils::middlewares::RedisCacheLayer;
//! use bb8_redis::RedisConnectionManager;
//!
//! #[derive(Clone)]
//! struct State {
//!    pub redis_pool: Pool<RedisConnectionManager>,
//! }
//!
//! let redis_pool = bb8::Pool::builder().build(redis_manager).await.unwrap();
//!
//! let state = Arc::new(State { redis_pool });
//!
//! let app = Router::new()
//!    .route(
//!       "/api/v1/users",
//!      get(handler.layer(RedisCacheLayer::<ResponseType>::new(state.redis_pool.clone())))
//!   )
//!   .with_state(state);
//! ```
//!
//! ResponsType needs to be a type that implements Deserialize, Serialize and FromRedisValue.
//!
//! The middleware can be configured with the `with_options` method, which receives a `RedisCacheOptions` struct.
//!
//! ```rust
//! use axum::{handler::get, Router};
//! use axum_redis_utils::middlewares::{RedisCacheLayerBuilder, RedisCacheOptions};
//! use std::sync::Arc;
//! use bb8_redis::RedisConnectionManager;
//!
//! #[derive(Clone)]
//! struct State {
//!    pub redis_pool: Pool<RedisConnectionManager>,
//! }
//!
//! let redis_pool = bb8::Pool::builder().build(redis_manager).await.unwrap();
//!
//! let state = Arc::new(State { redis_pool });
//!
//! let app = Router::new()
//!    .route(
//!       "/api/v1/users",
//!      get(handler.layer(RedisCacheLayerBuilder::new(redis_pool.clone()).with_expiration_time(600).build())
//!   )
//!   .with_state(state);
//! ```
//!
//! The code below it will set a expiration time of 600 seconds to the key api:v1:users. By default, any expiration time is set.
use axum::{
    body::Body,
    extract::Request,
    http::{HeaderMap, HeaderValue, StatusCode},
    response::{IntoResponse, Response},
    Json, RequestPartsExt,
};
use bb8::{Pool, PooledConnection};
use bb8_redis::RedisConnectionManager;
use futures_util::future::BoxFuture;
use http_body_util::BodyExt;
use redis::{AsyncCommands, FromRedisValue, JsonAsyncCommands};
use serde::{de::DeserializeOwned, Serialize};
use std::{
    fmt::Debug,
    marker::PhantomData,
    task::{Context, Poll},
};
use tower::{Layer, Service};

use super::{errors::RedisUtilsError, extractors::ExtractRedisKey};

#[derive(Clone, Debug)]
pub struct RedisCacheOptions {
    /// A value, in seconds, for the max-age the resource may be cached. This value will be used on the Cache-Control header as 'max-age=<value>'.
    pub expiration_time: Option<i64>,
    /// The redis path where the JSON object is going to be saved. It uses the root by default.
    pub path: Option<String>,
}

//
#[derive(Clone, Debug)]
pub struct RedisCacheLayerBuilder {
    options: RedisCacheOptions,
    redis_pool: Pool<RedisConnectionManager>,
}

impl RedisCacheLayerBuilder {
    pub fn new(redis_pool: Pool<RedisConnectionManager>) -> Self {
        RedisCacheLayerBuilder {
            redis_pool,
            options: RedisCacheOptions {
                expiration_time: None,
                path: None,
            },
        }
    }

    pub fn with_expiration_time(self, expiration_time: i64) -> Self {
        RedisCacheLayerBuilder {
            options: RedisCacheOptions {
                expiration_time: Some(expiration_time),
                ..self.options
            },
            ..self
        }
    }

    pub fn with_path(self, path: String) -> Self {
        RedisCacheLayerBuilder {
            options: RedisCacheOptions {
                path: Some(path),
                ..self.options
            },
            ..self
        }
    }

    pub fn build<ResponseType>(self) -> RedisCacheLayer<ResponseType> {
        RedisCacheLayer {
            redis_pool: self.redis_pool,
            options: self.options,
            phantom_data: PhantomData,
        }
    }
}

#[derive(Clone, Debug)]
pub struct RedisCacheLayer<ResponseType> {
    options: RedisCacheOptions,
    redis_pool: Pool<RedisConnectionManager>,
    phantom_data: PhantomData<ResponseType>,
}

impl<S, ResponseType> Layer<S> for RedisCacheLayer<ResponseType>
where
    ResponseType: DeserializeOwned + FromRedisValue + Serialize + Debug + Send + Sync,
{
    type Service = RedisCacheMiddleware<S, ResponseType>;

    fn layer(&self, inner: S) -> Self::Service {
        RedisCacheMiddleware {
            inner,
            redis_pool: self.redis_pool.clone(),
            options: self.options.clone(),
            phantom_data: PhantomData,
        }
    }
}

#[derive(Clone, Debug)]
pub struct RedisCacheMiddleware<S, ResponseType> {
    inner: S,
    redis_pool: Pool<RedisConnectionManager>,
    options: RedisCacheOptions,
    phantom_data: PhantomData<ResponseType>,
}

impl<S, ResponseType> Service<Request> for RedisCacheMiddleware<S, ResponseType>
where
    S: Service<Request, Response = Response> + Send + 'static,
    S::Future: Send + 'static,
    ResponseType: DeserializeOwned + FromRedisValue + Serialize + Debug + Send + Sync,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = BoxFuture<'static, Result<Self::Response, Self::Error>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    /// When there is a redis error, we return the response from the handler.
    fn call(&mut self, req: Request) -> Self::Future {
        let (mut parts, body) = req.into_parts();
        let redis_pool = self.redis_pool.clone();
        let options = self.options.clone();

        let request = Request::from_parts(parts.clone(), body);

        let future = self.inner.call(request);

        Box::pin(async move {
            let ExtractRedisKey(redis_key) = match parts.extract::<ExtractRedisKey>().await {
                Ok(key) => key,
                Err((_, _)) => {
                    let res: Response = future.await?;

                    return Ok(res);
                }
            };

            let mut redis_conn = match redis_pool.get().await {
                Ok(conn) => conn,
                Err(_) => {
                    let res: Response = future.await?;

                    return Ok(res);
                }
            };

            if redis_conn.exists(&redis_key).await.unwrap_or(false) {
                let redis_response_builder = RedisResponseBuilder::new(redis_conn, &redis_key);

                return Ok(redis_response_builder.build::<ResponseType>().await);
            }

            let res: Response = future.await?;
            let res_status: StatusCode = res.status();

            // If there is a response error, we return the response as we do not need to save on Redis.
            if res_status.is_client_error() || res_status.is_server_error() {
                return Ok(res);
            }

            // It builds the response from the handler and saves it to Redis before returning it.
            let handler_response_builder =
                HandlerResponseBuilder::new(redis_conn, &redis_key, options);

            Ok(handler_response_builder.build::<ResponseType>(res).await)
        })
    }
}

// Builds the middleware response based on the data coming from Redis cache
struct RedisResponseBuilder<'a> {
    redis_conn: PooledConnection<'a, RedisConnectionManager>,
    redis_key: &'a str,
}

impl<'a> RedisResponseBuilder<'a> {
    fn new(redis_conn: PooledConnection<'a, RedisConnectionManager>, redis_key: &'a str) -> Self {
        RedisResponseBuilder {
            redis_conn,
            redis_key,
        }
    }

    // Sets the Cache-Control header using the expiration time in seconds.
    fn set_cache_headers(
        &mut self,
        headers: &mut HeaderMap<HeaderValue>,
        expiration_time: Option<i64>,
    ) {
        // If the expiration time is less than or equal to zero, it means that the key exists but it does not contain
        // any expiration time. In this case, we do not set the Cache-Control header.
        let expiration_time: Option<i64> = expiration_time.filter(|time| *time > 0);

        if let Some(expiration_time) = expiration_time {
            headers.append(
                "Cache-Control",
                HeaderValue::from_str(&format!("max-age={}", expiration_time)).unwrap(),
            );
        }
    }

    async fn build<
        ResponseType: DeserializeOwned + FromRedisValue + Serialize + Debug + Send + Sync,
    >(
        mut self,
    ) -> Response {
        let res: ResponseType = match self.redis_conn.json_get(self.redis_key, "$").await {
            Ok(json) => json,
            Err(err) => {
                return (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()).into_response();
            }
        };

        let mut headers: HeaderMap<HeaderValue> = HeaderMap::new();

        let expiration_time = self.redis_conn.ttl(self.redis_key).await.unwrap_or(None);

        self.set_cache_headers(&mut headers, expiration_time);

        (StatusCode::OK, headers, Json(res)).into_response()
    }
}

// Builds the middleware response based on the data coming from a handler.
// It saves the response within redis before sending it back through the middleware chain.
struct HandlerResponseBuilder<'a> {
    redis_conn: PooledConnection<'a, RedisConnectionManager>,
    redis_key: &'a str,
    options: RedisCacheOptions,
}

impl<'a> HandlerResponseBuilder<'a> {
    fn new(
        redis_conn: PooledConnection<'a, RedisConnectionManager>,
        redis_key: &'a str,
        options: RedisCacheOptions,
    ) -> Self {
        HandlerResponseBuilder {
            redis_conn,
            redis_key,
            options,
        }
    }

    // Saves the response from the handler to Redis.
    async fn save_response_to_redis<
        ResponseType: DeserializeOwned + FromRedisValue + Serialize + Debug + Send + Sync,
    >(
        &mut self,
        key: &str,
        value: ResponseType,
        expiration_time: Option<i64>,
    ) -> Result<(), RedisUtilsError> {
        // Save response to Redis
        self.redis_conn
            .json_set::<&str, &str, ResponseType, ()>(key, "$", &value)
            .await
            .map_err(RedisUtilsError::Redis)?;

        // Set expiration time using the value from the options property
        if let Some(expiration_time) = expiration_time {
            self.redis_conn
                .expire::<&str, ()>(key, expiration_time)
                .await
                .map_err(RedisUtilsError::Redis)?;
        }

        Ok(())
    }

    async fn build<
        ResponseType: DeserializeOwned + FromRedisValue + Serialize + Debug + Send + Sync,
    >(
        mut self,
        res: Response,
    ) -> Response {
        let (parts, body) = res.into_parts();

        let bytes = match body.collect().await {
            Ok(collected) => collected.to_bytes(),
            Err(err) => {
                return (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()).into_response();
            }
        };
        let res_json_str = match String::from_utf8(bytes.to_vec()) {
            Ok(json_str) => json_str,
            Err(err) => {
                return (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()).into_response();
            }
        };
        let res_body: ResponseType = match serde_json::from_str(&res_json_str) {
            Ok(body) => body,
            Err(err) => {
                return (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()).into_response();
            }
        };

        if let Err(err) = self
            .save_response_to_redis(self.redis_key, res_body, self.options.expiration_time)
            .await
        {
            return (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()).into_response();
        };

        Response::from_parts(parts, Body::from(bytes))
    }
}
